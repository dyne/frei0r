/*
 * oklab.h -- Oklab to XYZ transformation or vice versa.
 * 
 * See `colorenhance.c' where the gamma table lookup is done for
 * converting sRGB to XYZ is done. The routines here are SIMD-optimized.
 *
 * Copyright (C) 2026 Cynthia (cynthia2048@proton.me)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <stdint.h>
#include <math.h>

#ifdef __SSE4_1__
#include <immintrin.h>
#endif

typedef struct {
    float x, y, z, _pad;
} ciexyz_t;

typedef struct {
    float l, a, b, _pad;
} oklab_t;

static const float gamma_expand_table[] = {
    0.000000, 0.000302, 0.000605, 0.000907, 0.001209, 0.001512, 0.001814, 0.002116,
    0.002419, 0.002721, 0.003023, 0.003333, 0.003661, 0.004007, 0.004371, 0.004754,
    0.005156, 0.005577, 0.006017, 0.006477, 0.006957, 0.007457, 0.007977, 0.008518,
    0.009080, 0.009663, 0.010267, 0.010893, 0.011540, 0.012209, 0.012900, 0.013614,
    0.014350, 0.015109, 0.015890, 0.016695, 0.017523, 0.018375, 0.019250, 0.020149,
    0.021072, 0.022019, 0.022991, 0.023987, 0.025008, 0.026054, 0.027125, 0.028221,
    0.029343, 0.030490, 0.031663, 0.032862, 0.034087, 0.035338, 0.036616, 0.037920,
    0.039250, 0.040608, 0.041993, 0.043404, 0.044844, 0.046310, 0.047804, 0.049326,
    0.050876, 0.052454, 0.054060, 0.055694, 0.057357, 0.059049, 0.060769, 0.062518,
    0.064296, 0.066103, 0.067940, 0.069806, 0.071701, 0.073626, 0.075581, 0.077566,
    0.079581, 0.081627, 0.083702, 0.085808, 0.087945, 0.090112, 0.092311, 0.094540,
    0.096800, 0.099092, 0.101414, 0.103769, 0.106155, 0.108572, 0.111021, 0.113503,
    0.116016, 0.118562, 0.121139, 0.123750, 0.126392, 0.129068, 0.131776, 0.134517,
    0.137291, 0.140098, 0.142938, 0.145812, 0.148719, 0.151659, 0.154633, 0.157641,
    0.160683, 0.163758, 0.166868, 0.170012, 0.173190, 0.176403, 0.179650, 0.182932,
    0.186248, 0.189599, 0.192985, 0.196407, 0.199863, 0.203354, 0.206881, 0.210443,
    0.214041, 0.217675, 0.221344, 0.225049, 0.228789, 0.232566, 0.236379, 0.240229,
    0.244114, 0.248036, 0.251995, 0.255990, 0.260021, 0.264090, 0.268196, 0.272338,
    0.276518, 0.280734, 0.284988, 0.289280, 0.293609, 0.297975, 0.302379, 0.306821,
    0.311300, 0.315818, 0.320374, 0.324967, 0.329599, 0.334269, 0.338978, 0.343725,
    0.348510, 0.353334, 0.358197, 0.363099, 0.368040, 0.373019, 0.378038, 0.383096,
    0.388193, 0.393329, 0.398505, 0.403721, 0.408976, 0.414270, 0.419605, 0.424979,
    0.430393, 0.435848, 0.441342, 0.446877, 0.452452, 0.458067, 0.463722, 0.469419,
    0.475155, 0.480933, 0.486751, 0.492610, 0.498510, 0.504451, 0.510434, 0.516457,
    0.522522, 0.528628, 0.534775, 0.540964, 0.547194, 0.553466, 0.559780, 0.566136,
    0.572533, 0.578973, 0.585455, 0.591978, 0.598544, 0.605152, 0.611803, 0.618496,
    0.625232, 0.632010, 0.638830, 0.645694, 0.652600, 0.659550, 0.666542, 0.673577,
    0.680656, 0.687777, 0.694942, 0.702150, 0.709402, 0.716697, 0.724036, 0.731419,
    0.738845, 0.746315, 0.753828, 0.761386, 0.768988, 0.776634, 0.784324, 0.792058,
    0.799837, 0.807660, 0.815527, 0.823439, 0.831396, 0.839397, 0.847443, 0.855533,
    0.863669, 0.871850, 0.880075, 0.888346, 0.896662, 0.905023, 0.913429, 0.921881,
    0.930378, 0.938921, 0.947509, 0.956143, 0.964823, 0.973548, 0.982320, 0.991137
};

static const uint8_t gamma_compress_table[] = {
      0,  12,  21,  28,  33,  38,  42,  46,  49,  52,  55,  58,  61,  63,  66,  68, 
     70,  73,  75,  77,  79,  81,  82,  84,  86,  88,  89,  91,  93,  94,  96,  97, 
     99, 100, 102, 103, 104, 106, 107, 109, 110, 111, 112, 114, 115, 116, 117, 118, 
    120, 121, 122, 123, 124, 125, 126, 127, 129, 130, 131, 132, 133, 134, 135, 136, 
    137, 138, 139, 140, 141, 142, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 
    151, 152, 153, 154, 155, 156, 157, 157, 158, 159, 160, 161, 161, 162, 163, 164, 
    165, 165, 166, 167, 168, 168, 169, 170, 171, 171, 172, 173, 174, 174, 175, 176, 
    176, 177, 178, 179, 179, 180, 181, 181, 182, 183, 183, 184, 185, 185, 186, 187, 
    187, 188, 189, 189, 190, 191, 191, 192, 193, 193, 194, 194, 195, 196, 196, 197, 
    197, 198, 199, 199, 200, 201, 201, 202, 202, 203, 204, 204, 205, 205, 206, 206, 
    207, 208, 208, 209, 209, 210, 210, 211, 212, 212, 213, 213, 214, 214, 215, 215, 
    216, 217, 217, 218, 218, 219, 219, 220, 220, 221, 221, 222, 222, 223, 223, 224, 
    224, 225, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 
    233, 233, 234, 234, 235, 235, 236, 236, 237, 237, 237, 238, 238, 239, 239, 240, 
    240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 245, 246, 246, 247, 247, 
    248, 248, 249, 249, 250, 250, 251, 251, 251, 252, 252, 253, 253, 254, 254, 255,
};

#ifdef __SSE4_1__
// GCC autovectorization :)
__m128 cbrt_sse(const __m128 u)
{
    union {
        float a[4];
        __m128 v;
    } cast;

    for(int i = 0; i < 4; ++i)
        cast.a[i] = cbrtf(u[i]);

    return cast.v;
}

__m128 pow3_sse(const __m128 u)
{
    return _mm_mul_ps(u, _mm_mul_ps(u, u));
}

static inline void ciexyz_to_oklab_sse4_1(const ciexyz_t* u, oklab_t *v) {    
    __m128 tmp0 = _mm_loadu_ps((const float*)u);
    __m128 tmp1;

    tmp1 =                 _mm_dp_ps(tmp0, _mm_setr_ps(0.412221f,  0.536332f,  0.051445f, 0.0f), 0b11110001);
    tmp1 = _mm_or_ps(tmp1, _mm_dp_ps(tmp0, _mm_setr_ps(0.211903f,  0.680699f,  0.107396f, 0.0f), 0b11110010));
    tmp1 = _mm_or_ps(tmp1, _mm_dp_ps(tmp0, _mm_setr_ps(0.088302f,  0.281718f,  0.629978f, 0.0f), 0b11110100));

    tmp0 = cbrt_sse(tmp1);

    tmp1 =                 _mm_dp_ps(tmp0, _mm_setr_ps(0.210454f,  0.793617f, -0.004072f, 0.0f), 0b11110001);
    tmp1 = _mm_or_ps(tmp1, _mm_dp_ps(tmp0, _mm_setr_ps(1.977998f, -2.428592f, +0.450593f, 0.0f), 0b11110010));
    tmp1 = _mm_or_ps(tmp1, _mm_dp_ps(tmp0, _mm_setr_ps(0.025904f,  0.782771f, -0.808675f, 0.0f), 0b11110100));

    tmp1 = _mm_mul_ps(_mm_add_ps(tmp1, _mm_setr_ps(0.0f, 0.5f, 0.5f, 0.0)), _mm_set1_ps(255.0f));
    _mm_storeu_ps((float*)v, tmp1);

    // v->l = CLAMP0255(v->l);
    // v->a = CLAMP0255(v->a);
    // v->b = CLAMP0255(v->b);
}

static inline void oklab_to_ciexyz_sse4_1(const oklab_t* u, ciexyz_t *v/*, bool scale */) {    
    __m128 tmp0 = _mm_loadu_ps((const float*)u);
    __m128 tmp1;

    tmp0 = _mm_sub_ps(_mm_mul_ps(tmp0, _mm_set1_ps(1/255.0f)), _mm_setr_ps(0.0f, 0.5f, 0.5f, 0.0));

    tmp1 =                 _mm_dp_ps(tmp0, _mm_setr_ps(1.0f,  0.396337f,  0.215803f, 0.0f), 0b11110001);
    tmp1 = _mm_or_ps(tmp1, _mm_dp_ps(tmp0, _mm_setr_ps(1.0f, -0.105561f, -0.063854f, 0.0f), 0b11110010));
    tmp1 = _mm_or_ps(tmp1, _mm_dp_ps(tmp0, _mm_setr_ps(1.0f, -0.089484f, -1.291485f, 0.0f), 0b11110100));

    tmp0 = pow3_sse(tmp1);

    tmp1 =                 _mm_dp_ps(tmp0, _mm_setr_ps( 4.076741f, -3.307711f,  0.230969f, 0.0f), 0b11110001);
    tmp1 = _mm_or_ps(tmp1, _mm_dp_ps(tmp0, _mm_setr_ps(-1.268438f, +2.609757f, -0.341319f, 0.0f), 0b11110010));
    tmp1 = _mm_or_ps(tmp1, _mm_dp_ps(tmp0, _mm_setr_ps(-0.004196f, -0.703418f, +1.707614f, 0.0f), 0b11110100));

    /* if (scale) */
        tmp1 = _mm_mul_ps(tmp1, _mm_set1_ps(255.0f));

    _mm_storeu_ps((float*)v, tmp1);

    // Clamp somewhere else, not here.
    // v->x = CLAMP0255(v->x);
    // v->y = CLAMP0255(v->y);
    // v->z = CLAMP0255(v->z);
}
#else
static oklab_t ciexyz_to_oklab(ciexyz_t u) {
    oklab_t v;
    float l, m, s; 

    l = cbrtf(0.412221f * u.x + 0.536332f * u.y + 0.051445f * u.z);
    m = cbrtf(0.211903f * u.x + 0.680699f * u.y + 0.107396f * u.z);
    s = cbrtf(0.088302f * u.x + 0.281718f * u.y + 0.629978f * u.z);

    v.l = (l * 0.210454f + m * 0.793617f - s * 0.004072f + 0   ) * 255.0f;
    v.a = (l * 1.977998f - m * 2.428592f + s * 0.450593f + 0.5f) * 255.0f;
    v.b = (l * 0.025904f + m * 0.782771f - s * 0.808675f + 0.5f) * 255.0f;

    return v;
}

ciexyz_t oklab_to_ciexyz(oklab_t u/*, bool scale */)
{
    ciexyz_t v;
    float l, m, s;

    u.l = u.l / 255.0f;
    u.a = u.a / 255.0f - 0.5f;
    u.b = u.b / 255.0f - 0.5f;

    l = powf(u.l + 0.396337f * u.a + 0.215803f * u.b, 3);
    m = powf(u.l - 0.105561f * u.a - 0.063854f * u.b, 3);
    s = powf(u.l - 0.089484f * u.a - 1.291485f * u.b, 3);

    v.x =  4.076741f * l - 3.307711f * m + 0.230969f * s;
    v.y = -1.268438f * l + 2.609757f * m - 0.341319f * s;
    v.z = -0.004196f * l - 0.703418f * m + 1.707614f * s;

    // if (scale)
    // {
        v.x *= 255.0f;
        v.y *= 255.0f;
        v.z *= 255.0f;
    // }

    return v;
}
#endif
